##  28/09/2017
##  Miquel simulations - extended
##
##  0. Parse arguments
library(optparse)
option_list = list(
make_option(c("-s", "--seed"), type="numeric", default=1,
help="Seed [default %default]", metavar="numeric"),
make_option(c("-n","--nb_replicates"), type="numeric", default=100,
help="Number of biological replicates [default %default]", metavar="numeric"),
make_option(c("-p","--permutations"), type="numeric", default=2,
help="Number of adonis permutations [default %default]", metavar="numeric"),
make_option(c("-m","--montecarlo"), type="numeric", default=1e7,
help="Number of Monte Carlo generations [default %default]", metavar="numeric"),
make_option(c("-c", "--cores"), type="numeric", default=1,
help="Number of cores [default %default]", metavar="numeric"),
make_option(c("-o", "--out"), type="character", default=NULL,
help="Output file name", metavar="character"),
make_option(c("-r", "--res"), type="character", default="~/PhD/projects/sqtlseeker/multifactorial/Miquel/results/simulation.abs.obs4_ss100.txt",
help="res file name", metavar="character")
)
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
if (is.null(opt$out)){
stop("At least one argument must be supplied (output file)\n", call.=FALSE)
}
## 1. Load packages and functions,
suppressPackageStartupMessages(library(vegan))
suppressPackageStartupMessages(library(CompQuadForm))
suppressPackageStartupMessages(library(car))
suppressPackageStartupMessages(library(MASS))
source("~/PhD/projects/sqtlseeker/multifactorial/Miquel/fx.miquel.extended.R")
## 2. Define simulation parameters and functions
set.seed(opt$seed)                    # Seed (provide job id)
# num genes (number of jobs, defined outside)
nS   <- 3                             # num splicing isoforms
a    <- 3                             # Factor A i.e. genotype               WARNING: Always balanced
b    <- 3                             # Factor B i.e. tissue / condition
n    <- opt$nb_replicates             # biological replicates (individuals)
N    <- a*b*n                         # Total number of individuals
nb.mont <- opt$montecarlo             # number of mc generations
nb.perm <- opt$permutations           # number of adonis permutations
nb.cores <- opt$cores                 # number of cores for parallel version
labelA <- gl(a, b*n)                  # df = a-1
labelB <- gl(b, n, length = N)        # df = b-1
labelI <- gl(n, 1, length = a*b*n)    # df = a*(n-1)
# Error df = a*b*c*n - 1 - (a-1) - (b-1) - (a-1)*(b-1) - a * (n-1) = N - a*b - a*(n-1) = a*(b-1)*(n-1)
res <- rep(NA, nb.mont)
## 3. Run
sigma <- diag(c(0.5, 0.4, 0.3))
dat <- t(mvrnorm(n = N, mu = c(0, 0, 0), Sigma = sigma))
dat[1, labelB == 3] <- dat[1, labelB == 3] + 3
d <- DistH2(dat)
ado <- adonis(as.dist(d) ~ labelA + labelB + labelI %in% labelA + labelA*labelB, permutations = nb.perm)
# Statistics
SSAB  <- ado$aov.tab[4,2]
SSE  <- ado$aov.tab[5,2]
FAB  <- ado$aov.tab[4,4]
# Adonis permutations (raw-data)
adonis.FAB.p <- ado$f.perms[, 4]
# RandomChisq
randomChisqN <- matrix(rchisq(nb.mont*nS, df = (a-1)*(b-1)), nrow = nS, ncol = nb.mont)
randomChisqD <- matrix(rchisq(nb.mont*nS, df = ( a*(b-1)*(n-1) )),
nrow = nS, ncol = nb.mont)
# Compute asymptotic McArtor
e <- eigenG(d, tol = 1e-10)
asymptNume   <- e %*% randomChisqN / ( (a-1)*(b-1) )
asymptDeno   <- e %*% randomChisqD / ( a*(b-1)*(n-1) )
asymptF <- asymptNume/asymptDeno
# Compute SS and residuals with linear regression on the square roots (centered)
Y <- t(dat)
Y2    <- scale(Y, center = T, scale = F)
CalvoModelF <- lm(Y2 ~ labelA + labelB + labelI %in% labelA + labelA*labelB)
Pronostic   <- CalvoModelF$residuals
UU <- Anova(CalvoModelF)
SSABCalvo <- sum(diag(UU$SSP$`labelA:labelB`))
SSECalvo  <- sum(diag(UU$SSPE))
e2 <- eigen(cov(Pronostic)*(N-1)/CalvoModelF$df.residual, symmetric=T, only.values=T)$values
# Compute asymptotic Calvo, proofed and conjectured
asymptNumeCalvo   <- e2 %*% randomChisqN / ((a-1) * (b-1))
asymptDenoCalvo   <- e2 %*% randomChisqD / ( a*(b-1)*(n-1) )
asymptFCalvo <- asymptNumeCalvo/asymptDenoCalvo
asymptDenoCalvoSum <- sum(e2)
asymptFCalvoSum <- asymptNumeCalvo/asymptDenoCalvoSum
# Load observed (empirical, mc)
res <- read.table(opt$res, header = F)[,1]
# pv's
sum(asymptF > FAB)/nb.mont
sum(asymptNume * (a-1)*(b-1) > SSAB)/nb.mont
sum(asymptFCalvo > FAB)/nb.mont
sum(asymptNumeCalvo * ((a-1) * (b-1)) > SSAB)/nb.mont
sum(asymptFCalvoSum > FAB)/nb.mont
sum(adonis.FAB.p > FAB)/nb.perm
sum(res > SSAB)/length(res)
# pdf("~/public_html/simulations/simulation.abs.obs.Y~A+B+C(A)+AB_ss.pdf", paper = "a4r", width = 10, height = 10)
plot(density(res), col = "green", main = "SSAB(H0)\nY ~ A + B + C(A) + AB\nB(H1)")
lines(density(asymptNumeCalvo* (a-1)*(b-1)), col = "blue")
lines(density(asymptNume* (a-1)*(b-1)), col = "orange")
legend("topright",c("Observed (empirical, MC)",
"Asympt. Calvo (Xi2*( eigen( cov(R) ) )/gl)",
"Asympt. McArtor (Xi2*( eigen( cov(G) ) )/gl)"),
col = c("green","blue","orange"), lty = 1)
# dev.off()
##
##  Diego Garrido Mart√≠n
##  28/09/2017
##  Miquel simulations - extended
##
##  0. Parse arguments
library(optparse)
option_list = list(
make_option(c("-s", "--seed"), type="numeric", default=1,
help="Seed [default %default]", metavar="numeric"),
make_option(c("-n","--nb_replicates"), type="numeric", default=100,
help="Number of biological replicates [default %default]", metavar="numeric"),
make_option(c("-p","--permutations"), type="numeric", default=2,
help="Number of adonis permutations [default %default]", metavar="numeric"),
make_option(c("-m","--montecarlo"), type="numeric", default=1e7,
help="Number of Monte Carlo generations [default %default]", metavar="numeric"),
make_option(c("-c", "--cores"), type="numeric", default=1,
help="Number of cores [default %default]", metavar="numeric"),
make_option(c("-o", "--out"), type="character", default=NULL,
help="Output file name", metavar="character"),
make_option(c("-r", "--res"), type="character", default="~/PhD/projects/sqtlseeker/multifactorial/Miquel/results/simulation.abs.obs4_f100.txt",
help="res file name", metavar="character")
)
opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser);
if (is.null(opt$out)){
stop("At least one argument must be supplied (output file)\n", call.=FALSE)
}
## 1. Load packages and functions,
suppressPackageStartupMessages(library(vegan))
suppressPackageStartupMessages(library(CompQuadForm))
suppressPackageStartupMessages(library(car))
suppressPackageStartupMessages(library(MASS))
source("~/PhD/projects/sqtlseeker/multifactorial/Miquel/fx.miquel.extended.R")
## 2. Define simulation parameters and functions
set.seed(opt$seed)                    # Seed (provide job id)
# num genes (number of jobs, defined outside)
nS   <- 3                             # num splicing isoforms
a    <- 3                             # Factor A i.e. genotype               WARNING: Always balanced
b    <- 3                             # Factor B i.e. tissue / condition
n    <- opt$nb_replicates             # biological replicates (individuals)
N    <- a*b*n                         # Total number of individuals
nb.mont <- opt$montecarlo             # number of mc generations
nb.perm <- opt$permutations           # number of adonis permutations
nb.cores <- opt$cores                 # number of cores for parallel version
labelA <- gl(a, b*n)                  # df = a-1
labelB <- gl(b, n, length = N)        # df = b-1
labelI <- gl(n, 1, length = a*b*n)    # df = a*(n-1)
# Error df = a*b*c*n - 1 - (a-1) - (b-1) - (a-1)*(b-1) - a * (n-1) = N - a*b - a*(n-1) = a*(b-1)*(n-1)
res <- rep(NA, nb.mont)
## 3. Run
sigma <- diag(c(0.5, 0.4, 0.3))
dat <- t(mvrnorm(n = N, mu = c(0, 0, 0), Sigma = sigma))
dat[1, labelB == 3] <- dat[1, labelB == 3] + 3
d <- DistH2(dat)
ado <- adonis(as.dist(d) ~ labelA + labelB + labelI %in% labelA + labelA*labelB, permutations = nb.perm)
# Statistics
SSAB  <- ado$aov.tab[4,2]
SSE  <- ado$aov.tab[5,2]
FAB  <- ado$aov.tab[4,4]
# Adonis permutations (raw-data)
adonis.FAB.p <- ado$f.perms[, 4]
# RandomChisq
randomChisqN <- matrix(rchisq(nb.mont*nS, df = (a-1)*(b-1)), nrow = nS, ncol = nb.mont)
randomChisqD <- matrix(rchisq(nb.mont*nS, df = ( a*(b-1)*(n-1) )),
nrow = nS, ncol = nb.mont)
# Compute asymptotic McArtor
e <- eigenG(d, tol = 1e-10)
asymptNume   <- e %*% randomChisqN / ( (a-1)*(b-1) )
asymptDeno   <- e %*% randomChisqD / ( a*(b-1)*(n-1) )
asymptF <- asymptNume/asymptDeno
# Compute SS and residuals with linear regression on the square roots (centered)
Y <- t(dat)
Y2    <- scale(Y, center = T, scale = F)
CalvoModelF <- lm(Y2 ~ labelA + labelB + labelI %in% labelA + labelA*labelB)
Pronostic   <- CalvoModelF$residuals
UU <- Anova(CalvoModelF)
SSABCalvo <- sum(diag(UU$SSP$`labelA:labelB`))
SSECalvo  <- sum(diag(UU$SSPE))
e2 <- eigen(cov(Pronostic)*(N-1)/CalvoModelF$df.residual, symmetric=T, only.values=T)$values
# Compute asymptotic Calvo, proofed and conjectured
asymptNumeCalvo   <- e2 %*% randomChisqN / ((a-1) * (b-1))
asymptDenoCalvo   <- e2 %*% randomChisqD / ( a*(b-1)*(n-1) )
asymptFCalvo <- asymptNumeCalvo/asymptDenoCalvo
asymptDenoCalvoSum <- sum(e2)
asymptFCalvoSum <- asymptNumeCalvo/asymptDenoCalvoSum
# Load observed (empirical, mc)
res <- read.table(opt$res, header = F)[,1]
# pv's
sum(asymptF > FAB)/nb.mont
sum(asymptNume * (a-1)*(b-1) > SSAB)/nb.mont
sum(asymptFCalvo > FAB)/nb.mont
sum(asymptNumeCalvo * ((a-1) * (b-1)) > SSAB)/nb.mont
sum(asymptFCalvoSum > FAB)/nb.mont
sum(adonis.FAB.p > FAB)/nb.perm
sum(res > FAB)/length(res)
# pdf("~/public_html/simulations/simulation.abs.obs.Y~A+B+C(A)+AB.pdf", paper = "a4r", width = 10, height = 10)
plot(density(asymptFCalvo), col = "blue", main = "FAB(H0)\nY ~ A + B + C(A) + AB\nB(H1)")
lines(density(asymptFCalvoSum), col = "cyan")
lines(density(adonis.FAB.p), col = "red")
lines(density(asymptF), col = "orange")
lines(density(res), col = "green")
legend("topright",c("Observed (empirical, MC)",
"Asympt. Calvo (SSAB/gl) / sum( eigen( cov(R) ) ) ",
"Asympt. Calvo (SSAB/gl) / (Xi2*( eigen( cov(R) ) )/gl)",
"Permuted (raw-data, adonis)",
"Asympt. McArtor (SSAB/gl) / (Xi2*( eigen( cov(G) ) )/gl)"),
col = c("green","blue","cyan","red","orange"), lty = 1)
# dev.off()
FAB
plot(density(asymptFCalvo), col = "blue", main = "FAB(H0)\nY ~ A + B + C(A) + AB\nB(H1)")
lines(density(asymptFCalvoSum), col = "cyan")
lines(density(asymptF), col = "orange")
lines(density(res), col = "green")
legend("topright",c("Observed (empirical, MC)",
"Asympt. Calvo (SSAB/gl) / sum( eigen( cov(R) ) ) ",
"Asympt. Calvo (SSAB/gl) / (Xi2*( eigen( cov(R) ) )/gl)",
"Asympt. McArtor (SSAB/gl) / (Xi2*( eigen( cov(G) ) )/gl)"),
col = c("green","blue","cyan","orange"), lty = 1)
library(data.table)
input_file <- "../sharing/input/input.tisspec.tsv"
dat <- fread(input_file, header = FALSE)
input_file <- "~/PhD/projects/GTEx/V7/sqtls/downstream/sharing/input/input.tisspec.tsv"
dat <- fread(input_file, header = FALSE)
colnames(dat) <- c("tissue", "gene", "tr1", "tr2", "snp", "md")
dat.safe <- dat
dat <- head(dat,1000)
dat %>% group_by(tr1,tr2,snp)
library(dplyr)
dat %>% group_by(tr1,tr2,snp)
dat2<-with(dat, cbind(tissue,paste(gene, tr1, tr2, snp)))
head(dat2)
dat2<-with(dat, cbind(tissue,paste(gene, tr1, tr2, snp, sep = "_"), md))
head(dat2)
dat2<-with(dat, data.frame(tissue, gene, test = paste(tr1, tr2, snp, sep = "_"), md))
head(dat2)
dat2<-with(dat, data.frame(tissue, gene, test = paste(tr1, tr2, snp, sep = "+"), md))
dat2
head(dat2)
dat2 <- with(dat, data.frame(tissue, gene,
test1 = paste(tr1, tr2, snp, sep = "+"),
test2 = paste(tr2, tr1, snp, sep = "+"),
md))
head(dat2)
dat <- head(dat,1000)
dat<-dat.safe
dat <- head(dat,1000)
head(dt)
head(dat)
i=1
dat[i,c(3,4)]
sort(dat[i,c(3,4)])
dat[i,c(3,4)] <- sort(dat[i,c(3,4)])
head(dat)
for (i in 1:dim(dat)[1]){
dat[i, c(3,4)] <- sort(dat[i, c(3,4)])
}
dat2 <- with(dat, data.frame(tissue, gene,
test = paste(tr1, tr2, snp, sep = "+"),
md))
dat <- with(dat, data.frame(tissue, gene,
test = paste(tr1, tr2, snp, sep = "+"),
md))
head(dat)
tb <-  dat %>% group_by(test) %>%
select(tissue, md) %>%
dcast(test ~ tissue, value.var = "md")
tb <-  dat %>% group_by(test) %>%
select(tissue, test, md) %>%
dcast(test ~ tissue, value.var = "md")
View(tb)
tb <-  dat %>% group_by(test) %>%
select(tissue, test, md) %>%
dcast(test ~ tissue, value.var = "md")
View(tb)
dat<-dat.safe
dat <- head(dat,sample(1:dim(dat)[1], size = 1000))
dim(dat)[1]
dat <- dat,sample(1:dim(dat)[1], size = 1000)
dat <- dat[sample(1:dim(dat)[1], size = 1000),]
for (i in 1:dim(dat)[1]){
dat[i, c(3,4)] <- sort(dat[i, c(3,4)])
}
dat <- with(dat, data.frame(tissue, gene,
test = paste(tr1, tr2, snp, sep = "+"),
md))
tb <-  dat %>% group_by(test) %>%
select(tissue, test, md) %>%
dcast(test ~ tissue, value.var = "md")
View(tb)
#!/usr/bin/env Rscript
#### Run FDR after permuted and nominal passes
## 1. Load libraries and arguments
library(optparse)
library(sQTLseekeR2)
library(data.table)
option_list = list(
make_option(c("-n", "--nominal"), type = "character",
help = "All nominal tests", metavar = "FILE"),
make_option(c("-p", "--permuted"), type = "character",
help = "All permuted tests", metavar = "FILE"),
make_option(c("-f", "--fdr"), type = "numeric", help = "FDR level",
metavar = "NUMERIC", default = 0.05),
make_option(c("-t", "--type_fdr"), type = "character", help = "FDR method (BH or qvalue)",
metavar = "CHARACTER", default = "BH"),
make_option(c("-o", "--output"), type = "character",
help = "Output file", metavar = "FILE")
)
opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)
fdr.level <- opt$fdr
fdr.method <- opt$type_fdr
nominal.f <- opt$nominal
permuted.f <- opt$permuted
output.f <- opt$output
fdr.level
fdr.level=1
setwd("/nfs/users2/rg/dgarrido/PhD/projects/sqtlseeker/sqtlseeker-nf/bin")
nominal.f<-"../result/groups/tissue1/all-tests.nominal.tsv"
permuted.f<- "../result/groups/tissue1/all-tests.permuted.tsv"
sqtls.p
pv <- md <- NULL
md.min = 0.05
FDR.svQTL = 0.05
svQTL.removal = FALSE
method = "BH"
any(colnames(res.nominal.df) == "pv.svQTL") & svQTL.removal
res.nominal.df <- as.data.frame(fread(nominal.f, header = TRUE, sep = "\t"), stringsAsFactors = FALSE)    # All tests
res.permuted.df <- as.data.frame(fread(permuted.f, header = TRUE, sep = "\t"), stringsAsFactors = FALSE)  # All tests
res.nominal.df$fdr.svQTL <- stats::p.adjust(res.nominal.df$pv.svQTL,
method = "BH")
any(colnames(res.nominal.df) == "pv.svQTL")
any(colnames(res.nominal.df) == "pv.svQTL") & svQTL.removal
method == "BH"
res.permuted.df$fdr <- stats::p.adjust(res.permuted.df$pv.emp.beta,
method = "BH")
set0 <- subset(res.permuted.df, fdr <= FDR)
FDR=1
set0 <- subset(res.permuted.df, fdr <= FDR)
set1 <- subset(res.permuted.df, fdr > FDR)
p_t <- (sort(set1$pv.emp.beta)[1] - sort(-1 * set0$pv.emp.beta)[1])/2
fdr_pt <- (sort(set1$fdr)[1] - sort(-1 * set0$fdr)[1])/2
res.permuted.df <- set0
res.nominal.df <- subset(res.nominal.df, geneId %in% res.permuted.df$geneId)
err <- abs(fdr_pt - FDR)
err
set0
set1
p_t
dim(set0)
dim(set1)
setwd("/nfs/users2/rg/dgarrido/PhD/projects/sqtlseeker/NEWsQTLseekeR/sQTLseekeR2/scripts")
##
#### Example of an analysis ran locally on a computer
##
## Due to the amount of genes/snps tested for a typical QTL analysis, it is recommended
## to use other computing resources. A parctical example, using BatchJobs package, is
## presented in 'run-example-BatchJobs.R' file.
##
## This example is here as a clearer summary of the workflow and for debugging purpose
## to check is the package is correctly installed and the inputs correctly formatted.
##
library(sQTLseekeR2)
## Input files: transcript expression, gene location and genotype information
trans.exp.f <- "../Data/transExpression.tsv.gz"
gene.bed.f <- "../Data/genes.bed"
genotype.f <- "../Data/snps-012coded.tsv"
## 1) Index the genotype file (if not done externally before)
genotype.indexed.f <- index.genotype(genotype.f)
te.df <- read.table(trans.exp.f, as.is=TRUE, header=TRUE, sep="\t")
prepare.trans.exp
tre1.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0)
tre2.df <- prepare.trans.exp(te.df, min.transcript.exp = 0.1, min.gene.exp = 0)
tre3.df <- prepare.trans.exp(te.df, min.transcript.exp = 0.1, min.gene.exp = 1)
View(tre2.df)
View(tre3.df)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 1)
View(tre4.df)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0)
unique(tre1.df$geneId)
unique(te.df$geneId)
unique(tre1.df$trId)
unique(te.df$trId)
all.equal(sort(unique(tre1.df$trId)),sort(unique(te.df$trId)))
which(!sort(unique(tre1.df$trId))%in%sort(unique(te.df$trId)))
which(!sort(unique(tre1.df$trId))%in%sort(unique(te.df$trId)))
which(!sort(unique(te.df$trId))%in%sort(unique(tre1.df$trId)))
sort(unique(te.df$trId))[39]
min.transcript.exp = 0.01
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0.01, min.gene.exp = 0.01)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0.01)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0, min.dispersion = 0)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0, min.dispersion = 0)
## to check is the package is correctly installed and the inputs correctly formatted.
##
library(sQTLseekeR2)
## Input files: transcript expression, gene location and genotype information
trans.exp.f <- "../Data/transExpression.tsv.gz"
gene.bed.f <- "../Data/genes.bed"
genotype.f <- "../Data/snps-012coded.tsv"
## 1) Index the genotype file (if not done externally before)
genotype.indexed.f <- index.genotype(genotype.f)
## 2) Prepare transcript expression
te.df <- read.table(trans.exp.f, as.is=TRUE, header=TRUE, sep="\t")
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0, min.dispersion = 0)
sort(unique(te.df$trId))[39]
te.df$trId[te.df$trId=="ENST00000491671.1"]
te.df[te.df$trId=="ENST00000491671.1",]
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = -1, min.gene.exp = 0, min.dispersion = 0)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 0, min.dispersion = 0)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = 0, min.gene.exp = 1, min.dispersion = 0)
which(!sort(unique(te.df$trId))%in%sort(unique(tre1.df$trId)))
which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))
sort(unique(te.df$trId))[which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))]
te.df[te.df$trId%in%sort(unique(te.df$trId))[which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))],]
View(te.df[te.df$trId%in%sort(unique(te.df$trId))[which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))],])
View(tre4.df[te.df$trId%in%sort(unique(te.df$trId))[which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))],])
te.df <- read.table(trans.exp.f, as.is=TRUE, header=TRUE, sep="\t")
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = -5, min.gene.exp = 1, min.dispersion = -5)
sort(unique(te.df$trId))[which(!sort(unique(te.df$trId))%in%sort(unique(tre4.df$trId)))]
sort(unique(te.df$geneId))
sort(unique(tre4.df$geneId))
View(te.df[te.df$geneId=="ENSG00000153162.7",])
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = -5, min.gene.exp = 0.5, min.dispersion = -5)
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = -5, min.gene.exp = 0.1, min.dispersion = -5)
View(te.df[te.df$geneId=="ENSG00000153162.7",])
te.df <- read.table(trans.exp.f, as.is=TRUE, header=TRUE, sep="\t")
tre4.df <- prepare.trans.exp(te.df, min.transcript.exp = -5, min.gene.exp = 0.1, min.dispersion = -5)
te.df <- read.table(trans.exp.f, as.is=TRUE, header=TRUE, sep="\t")
View(te.df[te.df$geneId=="ENSG00000153162.7",])
View(tre.df[tre.df$geneId=="ENSG00000153162.7",])
View(tre4.df[tre4.df$geneId=="ENSG00000153162.7",])
#!/usr/bin/env Rscript
#### Run FDR after permuted and nominal passes
## 1. Load libraries and arguments
library(optparse)
library(sQTLseekeR2)
library(data.table)
option_list = list(
make_option(c("-n", "--nominal"), type = "character",
help = "All nominal tests", metavar = "FILE"),
make_option(c("-p", "--permuted"), type = "character",
help = "All permuted tests", metavar = "FILE"),
make_option(c("-f", "--fdr"), type = "numeric", help = "FDR level",
metavar = "NUMERIC", default = 0.05),
make_option(c("-t", "--type_fdr"), type = "character", help = "FDR method (BH or qvalue)",
metavar = "CHARACTER", default = "BH"),
make_option(c("-o", "--output"), type = "character",
help = "Output file", metavar = "FILE")
)
opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)
fdr.level <- opt$fdr
fdr.method <- opt$type_fdr
nominal.f <- opt$nominal
permuted.f <- opt$permuted
output.f <- opt$output
## 2. Input file: all tests  (nominal and permuted)
res.nomina
setwd("/nfs/users2/rg/dgarrido/PhD/projects/sqtlseeker/sqtlseeker-nf/scripts")
setwd("/nfs/users2/rg/dgarrido/PhD/projects/sqtlseeker/sqtlseeker-nf/scripts")
nominal.f<-"../result/groups/tissue1/all-tests.nominal.tsv"
permuted.f<-"../work/cc/714263a594cf836f51ca967030ef23/all-tests.permuted.tsv"
res.nominal.df <- as.data.frame(fread(nominal.f, header = TRUE, sep = "\t"), stringsAsFactors = FALSE)    # All tests
res.permuted.df <- as.data.frame(fread(permuted.f, header = TRUE, sep = "\t"), stringsAsFactors = FALSE)  # All tests
sqtls.p
FDR = 0.05
method = "BH"
md.min = 0.05
svQTL.removal = FALSE
FDR.svQTL = 0.05
if (any(colnames(res.nominal.df) == "pv.svQTL") & svQTL.removal) {
if (method == "BH") {
res.nominal.df$fdr.svQTL <- stats::p.adjust(res.nominal.df$pv.svQTL,
method = "BH")
}
else if (method == "qvalue") {
res.nominal.df$fdr.svQTL <- qvalue::qvalue(res.nominal.df$pv.svQTL)$qvalues
}
else {
stop("Available methods for FDR are 'BH' and 'qvalue'.")
}
}
if (method == "BH") {
res.permuted.df$fdr <- stats::p.adjust(res.permuted.df$pv.emp.beta,
method = "BH")
}
any(colnames(res.nominal.df) == "pv.svQTL")
svQTL.removal
any(colnames(res.nominal.df) == "pv.svQTL") & svQTL.removal
if (any(colnames(res.nominal.df) == "pv.svQTL") & svQTL.removal) {
if (method == "BH") {
res.nominal.df$fdr.svQTL <- stats::p.adjust(res.nominal.df$pv.svQTL,
method = "BH")
}
else if (method == "qvalue") {
res.nominal.df$fdr.svQTL <- qvalue::qvalue(res.nominal.df$pv.svQTL)$qvalues
}
else {
stop("Available methods for FDR are 'BH' and 'qvalue'.")
}
}
if (method == "BH") {
res.permuted.df$fdr <- stats::p.adjust(res.permuted.df$pv.emp.beta,
method = "BH")
}
res.permuted.df
View(res.permuted.df)
